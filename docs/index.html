<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>India Boundary Corrector - Config Editor</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script type="importmap">
    {
      "imports": {
        "@india-boundary-corrector/data": "./packages/data/index.js",
        "@india-boundary-corrector/layer-configs": "./packages/layer-configs/dist/index.js",
        "@india-boundary-corrector/tilefixer": "./packages/tilefixer/dist/index.js",
        "@india-boundary-corrector/leaflet-layer": "./packages/leaflet-layer/dist/index.js",
        "pmtiles": "https://esm.sh/pmtiles@4.0.1"
      }
    }
  </script>
  <style>
    * { box-sizing: border-box; }
    body { 
      margin: 0; 
      padding: 0; 
      font-family: system-ui, -apple-system, sans-serif;
      display: flex;
      height: 100vh;
    }
    
    #sidebar {
      width: 400px;
      min-width: 300px;
      padding: 15px;
      background: #f5f5f5;
      overflow-y: auto;
      border-right: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    #sidebar h1 {
      margin: 0;
      font-size: 1.3rem;
      color: #333;
    }
    
    #sidebar h2 {
      margin: 0 0 8px 0;
      font-size: 1rem;
      color: #555;
    }
    
    .section {
      background: white;
      padding: 12px;
      border-radius: 6px;
      border: 1px solid #ddd;
    }
    
    label {
      display: block;
      margin-bottom: 4px;
      font-size: 0.85rem;
      color: #666;
    }
    
    input[type="text"], select, textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.9rem;
      font-family: inherit;
    }
    
    input[type="text"]:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #007bff;
    }
    
    textarea {
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.8rem;
      resize: vertical;
    }
    
    #configEditor {
      min-height: 300px;
    }
    
    button {
      padding: 10px 16px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    
    button:hover {
      background: #0056b3;
    }
    
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .error {
      color: #dc3545;
      font-size: 0.85rem;
      margin-top: 5px;
    }
    
    .success {
      color: #28a745;
      font-size: 0.85rem;
      margin-top: 5px;
    }
    
    #map { 
      flex: 1;
      height: 100%;
    }
    
    /* Color Picker Control */
    .color-picker-control {
      background: white;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      padding: 6px;
      cursor: pointer;
    }
    
    .color-picker-control.active {
      background: #007bff;
      color: white;
    }
    
    .color-picker-control svg {
      display: block;
      width: 24px;
      height: 24px;
    }
    
    .color-picker-control.active svg {
      fill: white;
    }
    
    /* Color Picker Popup */
    .color-picker-popup {
      position: absolute;
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      padding: 12px;
      z-index: 1000;
      display: none;
      min-width: 180px;
    }
    
    .color-picker-popup.visible {
      display: block;
    }
    
    .color-picker-magnifier {
      width: 150px;
      height: 150px;
      border: 2px solid #333;
      border-radius: 4px;
      margin-bottom: 10px;
      image-rendering: pixelated;
      position: relative;
      overflow: hidden;
    }
    
    .color-picker-magnifier canvas {
      display: block;
    }
    
    .color-picker-crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    
    .color-picker-crosshair::before,
    .color-picker-crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
      box-shadow: 0 0 2px rgba(0,0,0,0.5);
    }
    
    .color-picker-crosshair::before {
      width: 1px;
      height: 20px;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }
    
    .color-picker-crosshair::after {
      width: 20px;
      height: 1px;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }
    
    .color-picker-info {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .color-picker-swatch {
      width: 40px;
      height: 40px;
      border: 2px solid #333;
      border-radius: 4px;
      flex-shrink: 0;
    }
    
    .color-picker-values {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .color-picker-values div {
      cursor: pointer;
    }
    
    .color-picker-values div:hover {
      background: #f0f0f0;
    }
    
    #map.color-picker-active {
      cursor: crosshair;
    }
    
    .tile-preset {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .tile-preset button {
      flex: 1;
      padding: 6px 10px;
      font-size: 0.8rem;
      background: #6c757d;
    }
    
    .tile-preset button:hover {
      background: #545b62;
    }
    
    .tile-preset button.active {
      background: #007bff;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h1>üó∫Ô∏è India Boundary Corrector</h1>
    <p style="margin: 0; font-size: 0.85rem; color: #666;">Config Editor - Test different tile layers and layer configurations</p>
    
    <div class="section">
      <h2>PMTiles URL</h2>
      <input type="text" id="pmtilesUrl" value="packages/data/india_boundary_corrections.pmtiles">
    </div>
    
    <div class="section">
      <h2>Tile Layer</h2>
      <div class="tile-preset">
        <button id="btnCartoDark" class="active">Carto Dark</button>
        <button id="btnOsmCarto">OSM Carto</button>
        <button id="btnCustom">Custom</button>
      </div>
      <label for="tileUrl">Tile URL Template</label>
      <input type="text" id="tileUrl" value="https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png">
      <label for="tileAttribution" style="margin-top: 8px;">Attribution</label>
      <input type="text" id="tileAttribution" value="&copy; OpenStreetMap &copy; CARTO">
    </div>
    
    <div class="section">
      <h2>Layer Config</h2>
      <textarea id="configEditor">{
  "id": "cartodb-dark",
  "startZoom": 0,
  "zoomThreshold": 5,
  "tileUrlPattern": "(cartocdn\\.com|cartodb-basemaps).*dark_all",
  "osmAddLineColor": "rgb(40, 40, 40)",
  "neAddLineColor": "rgb(40, 40, 40)",
  "addLineDashed": false,
  "addLineDashArray": [],
  "addLineHaloRatio": 0,
  "addLineHaloAlpha": 0,
  "lineWidthMultiplier": 1.0
}</textarea>
      <div id="configStatus"></div>
    </div>
    
    <button id="applyBtn">Apply Configuration</button>
    
    <div class="section" style="margin-top: auto;">
      <h2>Resources</h2>
      <ul style="margin: 0; padding-left: 20px; font-size: 0.85rem;">
        <li><a href="examples/">Examples</a></li>
        <li><a href="https://github.com/ramSeraph/india_boundary_corrector">GitHub Repository</a></li>
      </ul>
    </div>
  </div>
  
  <div id="map"></div>
  
  <!-- Color Picker Popup -->
  <div id="colorPickerPopup" class="color-picker-popup">
    <div class="color-picker-magnifier">
      <canvas id="magnifierCanvas" width="150" height="150"></canvas>
      <div class="color-picker-crosshair"></div>
    </div>
    <div class="color-picker-info">
      <div id="colorSwatch" class="color-picker-swatch"></div>
      <div class="color-picker-values">
        <div id="rgbValue" title="Click to copy">RGB: --</div>
        <div id="hexValue" title="Click to copy">HEX: --</div>
      </div>
    </div>
  </div>

  <script type="module">
    import L from 'https://esm.sh/leaflet@1.9.4';
    import { extendLeaflet } from './packages/leaflet-layer/dist/index.js';
    import { LayerConfig } from './packages/layer-configs/dist/index.js';
    
    // Extend Leaflet with IndiaBoundaryCorrectedTileLayer
    extendLeaflet(L);

    // Preset configs
    const presets = {
      cartoDark: {
        tileUrl: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
        attribution: '&copy; OpenStreetMap &copy; CARTO',
        config: {
          id: 'cartodb-dark',
          startZoom: 0,
          zoomThreshold: 5,
          tileUrlPattern: '(cartocdn\\.com|cartodb-basemaps).*dark_all',
          osmAddLineColor: 'rgb(40, 40, 40)',
          neAddLineColor: 'rgb(40, 40, 40)',
          addLineDashed: false,
          addLineDashArray: [],
          addLineHaloRatio: 0,
          addLineHaloAlpha: 0,
          lineWidthMultiplier: 1.0
        }
      },
      osmCarto: {
        tileUrl: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
        attribution: '&copy; OpenStreetMap contributors',
        config: {
          id: 'osm-carto',
          startZoom: 1,
          zoomThreshold: 1,
          tileUrlPattern: 'tile\\.openstreetmap\\.org.*\\.png',
          osmAddLineColor: '#b9a8b9',
          neAddLineColor: '#b9a8b9',
          addLineDashed: true,
          addLineDashArray: [10, 1, 2, 1],
          addLineHaloRatio: 1.0,
          addLineHaloAlpha: 0.5,
          lineWidthMultiplier: 1.5
        }
      },
      custom: {
        tileUrl: 'https://tile.openstreetmap.de/{z}/{x}/{y}.png',
        attribution: '&copy; OpenStreetMap contributors',
        config: {
          id: 'custom',
          startZoom: 0,
          zoomThreshold: 5,
          // tileUrlPattern: 'your-pattern-here',
          osmAddLineColor: 'rgb(180, 195, 180)',
          neAddLineColor: 'rgb(180, 195, 180)',
          addLineDashed: true,
          addLineDashArray: [10, 1, 2, 1],
          addLineHaloRatio: 1.0,
          addLineHaloAlpha: 0.5,
          lineWidthMultiplier: 1.0
        }
      }
    };

    let currentPreset = 'cartoDark';
    let map = null;
    let currentLayer = null;

    // DOM elements
    const pmtilesUrlInput = document.getElementById('pmtilesUrl');
    const tileUrlInput = document.getElementById('tileUrl');
    const tileAttributionInput = document.getElementById('tileAttribution');
    const configEditor = document.getElementById('configEditor');
    const configStatus = document.getElementById('configStatus');
    const applyBtn = document.getElementById('applyBtn');
    const btnCartoDark = document.getElementById('btnCartoDark');
    const btnOsmCarto = document.getElementById('btnOsmCarto');
    const btnCustom = document.getElementById('btnCustom');

    function setActiveButton(preset) {
      btnCartoDark.classList.toggle('active', preset === 'cartoDark');
      btnOsmCarto.classList.toggle('active', preset === 'osmCarto');
      btnCustom.classList.toggle('active', preset === 'custom');
    }

    function loadPreset(preset) {
      currentPreset = preset;
      const p = presets[preset];
      tileUrlInput.value = p.tileUrl;
      tileAttributionInput.value = p.attribution;
      configEditor.value = JSON.stringify(p.config, null, 2);
      setActiveButton(preset);
      configStatus.innerHTML = '';
    }

    function parseConfig() {
      try {
        const config = JSON.parse(configEditor.value);
        configStatus.innerHTML = '<span class="success">‚úì Valid JSON</span>';
        return config;
      } catch (e) {
        configStatus.innerHTML = `<span class="error">‚úó Invalid JSON: ${e.message}</span>`;
        return null;
      }
    }

    function applyConfiguration() {
      const configObj = parseConfig();
      if (!configObj) return;

      const pmtilesUrl = pmtilesUrlInput.value.trim();
      const tileUrl = tileUrlInput.value.trim();
      const attribution = tileAttributionInput.value;

      if (!pmtilesUrl) {
        configStatus.innerHTML = '<span class="error">‚úó PMTiles URL is required</span>';
        return;
      }

      if (!tileUrl) {
        configStatus.innerHTML = '<span class="error">‚úó Tile URL is required</span>';
        return;
      }

      try {
        const layerConfig = new LayerConfig(configObj);

        // Remove existing layer
        if (currentLayer) {
          map.removeLayer(currentLayer);
        }

        // Create new corrected tile layer
        currentLayer = L.tileLayer.indiaBoundaryCorrected(tileUrl, {
          attribution,
          maxZoom: 19,
          pmtilesUrl,
          layerConfig
        }).addTo(map);

        configStatus.innerHTML = '<span class="success">‚úì Configuration applied!</span>';
      } catch (e) {
        configStatus.innerHTML = `<span class="error">‚úó Error: ${e.message}</span>`;
      }
    }

    // Initialize map
    map = L.map('map').setView([28.6, 77.2], 5);

    // ========== Color Picker Control ==========
    const ColorPickerControl = L.Control.extend({
      options: { position: 'topleft' },
      
      onAdd: function(map) {
        this._map = map;
        this._active = false;
        
        const container = L.DomUtil.create('div', 'leaflet-bar color-picker-control');
        container.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor">
          <path d="M20.71 5.63l-2.34-2.34a1 1 0 00-1.41 0l-3.12 3.12-1.93-1.91-1.41 1.41 1.42 1.42L3 16.25V21h4.75l8.92-8.92 1.42 1.42 1.41-1.41-1.92-1.92 3.12-3.12a1 1 0 00.01-1.42zM6.92 19L5 17.08l8.06-8.06 1.92 1.92L6.92 19z"/>
        </svg>`;
        container.title = 'Color Picker';
        
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.on(container, 'click', this._toggle, this);
        
        this._container = container;
        return container;
      },
      
      _toggle: function() {
        this._active = !this._active;
        this._container.classList.toggle('active', this._active);
        this._map.getContainer().classList.toggle('color-picker-active', this._active);
        
        if (this._active) {
          colorPicker.enable();
        } else {
          colorPicker.disable();
        }
      },
      
      deactivate: function() {
        if (this._active) {
          this._active = false;
          this._container.classList.remove('active');
          this._map.getContainer().classList.remove('color-picker-active');
        }
      }
    });

    // Color Picker functionality
    const colorPicker = {
      popup: document.getElementById('colorPickerPopup'),
      canvas: document.getElementById('magnifierCanvas'),
      ctx: null,
      swatch: document.getElementById('colorSwatch'),
      rgbValue: document.getElementById('rgbValue'),
      hexValue: document.getElementById('hexValue'),
      enabled: false,
      magnification: 10,
      
      init: function() {
        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
        
        // Copy to clipboard on click
        this.rgbValue.addEventListener('click', () => this.copyToClipboard(this.rgbValue.textContent));
        this.hexValue.addEventListener('click', () => this.copyToClipboard(this.hexValue.textContent));
      },
      
      enable: function() {
        this.enabled = true;
        map.on('mousemove', this.onMouseMove, this);
        map.on('click', this.onClick, this);
        document.addEventListener('keydown', this.onKeyDown);
        
        // Position popup below the color picker control
        this.positionPopup();
        this.popup.classList.add('visible');
      },
      
      disable: function() {
        this.enabled = false;
        this.popup.classList.remove('visible');
        map.off('mousemove', this.onMouseMove, this);
        map.off('click', this.onClick, this);
        document.removeEventListener('keydown', this.onKeyDown);
      },
      
      onKeyDown: function(e) {
        if (e.key === 'Escape') {
          colorPickerControl.deactivate();
          colorPicker.disable();
        }
      },
      
      positionPopup: function() {
        // Position below the color picker control button
        const control = document.querySelector('.color-picker-control');
        if (control) {
          const rect = control.getBoundingClientRect();
          this.popup.style.left = rect.left + 'px';
          this.popup.style.top = (rect.bottom + 10) + 'px';
        }
      },
      
      onMouseMove: function(e) {
        if (!this.enabled) return;
        
        const mapContainer = map.getContainer();
        const rect = mapContainer.getBoundingClientRect();
        const x = e.originalEvent.clientX - rect.left;
        const y = e.originalEvent.clientY - rect.top;
        
        // Capture and magnify the area under cursor
        this.captureAndMagnify(x, y);
      },
      
      onClick: function(e) {
        // On click, copy the hex value
        const hex = this.hexValue.textContent;
        if (hex && hex !== 'HEX: --') {
          this.copyToClipboard(hex);
        }
      },
      
      captureAndMagnify: function(x, y) {
        const mapContainer = map.getContainer();
        
        // Use html2canvas-like approach: capture from the map's canvas/tiles
        // We'll use a temporary canvas to composite all visible layers
        const captureSize = Math.ceil(this.canvas.width / this.magnification);
        const halfSize = Math.floor(captureSize / 2);
        
        // Find all tile images and canvas elements in the map
        const pane = mapContainer.querySelector('.leaflet-tile-pane');
        if (!pane) return;
        
        // Create offscreen canvas matching map size
        const offscreen = document.createElement('canvas');
        const mapRect = mapContainer.getBoundingClientRect();
        offscreen.width = mapRect.width;
        offscreen.height = mapRect.height;
        const offCtx = offscreen.getContext('2d');
        
        // Draw all tile images
        const tiles = pane.querySelectorAll('img');
        tiles.forEach(img => {
          if (!img.complete || !img.naturalWidth) return;
          
          const imgRect = img.getBoundingClientRect();
          const drawX = imgRect.left - mapRect.left;
          const drawY = imgRect.top - mapRect.top;
          
          try {
            offCtx.drawImage(img, drawX, drawY, imgRect.width, imgRect.height);
          } catch (e) {
            // Cross-origin image, skip
          }
        });
        
        // Extract the region around the cursor
        const sourceX = Math.max(0, x - halfSize);
        const sourceY = Math.max(0, y - halfSize);
        
        // Clear and draw magnified view
        this.ctx.fillStyle = '#888';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        try {
          // Disable smoothing for pixelated look
          this.ctx.imageSmoothingEnabled = false;
          this.ctx.drawImage(
            offscreen,
            sourceX, sourceY, captureSize, captureSize,
            0, 0, this.canvas.width, this.canvas.height
          );
          
          // Get center pixel color
          const centerX = Math.floor(this.canvas.width / 2);
          const centerY = Math.floor(this.canvas.height / 2);
          const pixel = this.ctx.getImageData(centerX, centerY, 1, 1).data;
          
          const r = pixel[0];
          const g = pixel[1];
          const b = pixel[2];
          
          const rgbStr = `rgb(${r}, ${g}, ${b})`;
          const hexStr = '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('').toUpperCase();
          
          this.swatch.style.background = rgbStr;
          this.rgbValue.textContent = `RGB: ${r}, ${g}, ${b}`;
          this.hexValue.textContent = `HEX: ${hexStr}`;
        } catch (e) {
          // Handle any errors
          this.rgbValue.textContent = 'RGB: --';
          this.hexValue.textContent = 'HEX: --';
        }
      },
      
      copyToClipboard: function(text) {
        const value = text.replace(/^(RGB|HEX):\s*/, '');
        navigator.clipboard.writeText(value).then(() => {
          // Brief visual feedback
          const origText = text;
          if (text.startsWith('RGB')) {
            this.rgbValue.textContent = 'Copied!';
            setTimeout(() => this.rgbValue.textContent = origText, 1000);
          } else {
            this.hexValue.textContent = 'Copied!';
            setTimeout(() => this.hexValue.textContent = origText, 1000);
          }
        });
      }
    };

    // Initialize color picker
    colorPicker.init();
    const colorPickerControl = new ColorPickerControl();
    map.addControl(colorPickerControl);

    // Event listeners
    btnCartoDark.addEventListener('click', () => loadPreset('cartoDark'));
    btnOsmCarto.addEventListener('click', () => loadPreset('osmCarto'));
    btnCustom.addEventListener('click', () => loadPreset('custom'));
    applyBtn.addEventListener('click', applyConfiguration);
    configEditor.addEventListener('input', parseConfig);

    // Initial apply
    applyConfiguration();
  </script>
</body>
</html>
