<!DOCTYPE html>
<html>
<head>
  <title>MapLibre Package Test</title>
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.css" />
  <style>
    #map { width: 800px; height: 600px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <script src="https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.js"></script>
  <script type="importmap">
    {
      "imports": {
        "pmtiles": "https://esm.sh/pmtiles@3.0.0",
        "@india-boundary-corrector/data": "/packages/data/index.js",
        "@india-boundary-corrector/layer-configs": "/packages/layer-configs/src/index.js",
        "@india-boundary-corrector/maplibre": "/packages/maplibre/src/index.js"
      }
    }
  </script>
  <script type="module">
    import { Protocol } from 'pmtiles';
    import { 
      BoundaryCorrector, 
      addBoundaryCorrector, 
      removeBoundaryCorrector,
      layerConfigs,
      getPmtilesUrl
    } from '@india-boundary-corrector/maplibre';

    // Register PMTiles protocol for real map
    const protocol = new Protocol();
    maplibregl.addProtocol('pmtiles', protocol.tile);

    /**
     * Mock MapLibre Map class for testing without WebGL
     */
    class MockMap {
      constructor(options = {}) {
        this._sources = {};
        this._layers = [];
        this._handlers = {};
        
        // Initialize from style if provided
        if (options.style) {
          if (options.style.sources) {
            this._sources = { ...options.style.sources };
          }
          if (options.style.layers) {
            this._layers = [...options.style.layers];
          }
        }
      }

      getStyle() {
        return {
          version: 8,
          sources: { ...this._sources },
          layers: [...this._layers]
        };
      }

      getSource(id) {
        const sourceSpec = this._sources[id];
        if (!sourceSpec) return undefined;
        
        // Return a source-like object with tiles property
        return {
          type: sourceSpec.type,
          tiles: sourceSpec.tiles || [],
        };
      }

      getLayer(id) {
        return this._layers.find(l => l.id === id);
      }

      addSource(id, source) {
        if (this._sources[id]) {
          throw new Error(`Source "${id}" already exists`);
        }
        this._sources[id] = source;
        this._emit('styledata', {});
      }

      addLayer(layer, beforeId) {
        if (this._layers.find(l => l.id === layer.id)) {
          throw new Error(`Layer "${layer.id}" already exists`);
        }
        
        if (beforeId) {
          const index = this._layers.findIndex(l => l.id === beforeId);
          if (index >= 0) {
            this._layers.splice(index, 0, layer);
          } else {
            this._layers.push(layer);
          }
        } else {
          this._layers.push(layer);
        }
        this._emit('styledata', {});
      }

      removeSource(id) {
        delete this._sources[id];
        this._emit('styledata', {});
      }

      removeLayer(id) {
        const index = this._layers.findIndex(l => l.id === id);
        if (index >= 0) {
          this._layers.splice(index, 1);
        }
        this._emit('styledata', {});
      }

      on(event, handler) {
        if (!this._handlers[event]) {
          this._handlers[event] = [];
        }
        this._handlers[event].push(handler);
      }

      off(event, handler) {
        if (!this._handlers[event]) return;
        const index = this._handlers[event].indexOf(handler);
        if (index >= 0) {
          this._handlers[event].splice(index, 1);
        }
      }

      _emit(event, data) {
        if (!this._handlers[event]) return;
        for (const handler of this._handlers[event]) {
          handler(data);
        }
      }
    }

    /**
     * Creates a map based on mode (mock or real)
     * @param {'mock' | 'real'} mode - The map mode
     * @param {Object} options - Map options
     * @returns {Promise<MockMap | maplibregl.Map>}
     */
    async function createTestMap(mode, options = {}) {
      if (mode === 'mock') {
        return new MockMap(options);
      }

      // Real MapLibre map
      const defaultOptions = {
        container: 'map',
        style: options.style || {
          version: 8,
          sources: {},
          layers: []
        }
      };

      const map = new maplibregl.Map({ ...defaultOptions, ...options });
      
      // Wait for map to be ready with timeout
      // The 'load' event fires when style is loaded, but tiles may still be loading
      // For tests with invalid URLs, we use 'style.load' which fires earlier
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          resolve(); // Resolve anyway after timeout
        }, 5000);
        
        map.on('load', () => {
          clearTimeout(timeout);
          resolve();
        });
      });

      return map;
    }

    // Expose for testing
    window.MockMap = MockMap;
    window.createTestMap = createTestMap;
    window.maplibregl = maplibregl;
    window.maplibrePackage = {
      BoundaryCorrector,
      addBoundaryCorrector,
      removeBoundaryCorrector,
      layerConfigs,
      getPmtilesUrl
    };
    
    window.testReady = true;
  </script>
</body>
</html>
