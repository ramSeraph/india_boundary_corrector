<!DOCTYPE html>
<html>
<head>
  <title>Leaflet Layer Test</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "@india-boundary-corrector/data": "/packages/data/index.js",
        "@india-boundary-corrector/tilefixer": "/packages/tilefixer/dist/index.js",
        "@india-boundary-corrector/layer-configs": "/packages/layer-configs/dist/index.js",
        "@india-boundary-corrector/leaflet-layer": "/packages/leaflet-layer/dist/index.js"
      }
    }
  </script>
  <script type="module">
    import { extendLeaflet } from '@india-boundary-corrector/leaflet-layer';
    
    // Extend Leaflet with the corrected tile layer
    extendLeaflet(L);

    // Create a test layer instance
    const testLayer = L.tileLayer.indiaBoundaryCorrected(
      'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
      { layerConfig: 'osm-carto' }
    );

    // Mock fetch for testing different scenarios
    const originalFetch = window.fetch;
    
    // Create mock tile data (1x1 white PNG)
    const createMockTile = () => {
      const canvas = new OffscreenCanvas(256, 256);
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, 256, 256);
      return canvas.convertToBlob({ type: 'image/png' }).then(blob => blob.arrayBuffer());
    };

    // Create corrupted data
    const createCorruptedData = () => {
      const arr = new Uint8Array(100);
      for (let i = 0; i < 100; i++) {
        arr[i] = Math.floor(Math.random() * 256);
      }
      return Promise.resolve(arr.buffer);
    };

    // Mock URL generator with different scenarios
    window.createMockTileUrl = (scenario) => {
      return `mock://${scenario}/tile.png`;
    };

    // Override fetch to handle mock URLs
    window.fetch = function(url, ...args) {
      // Intercept broken PMTiles URL
      if (typeof url === 'string' && url.includes('broken.pmtiles')) {
        return Promise.reject(new Error('PMTiles fetch failed: network error'));
      }
      
      if (typeof url === 'string' && url.startsWith('mock://')) {
        const parts = url.split('/');
        const scenario = parts[2];

        switch (scenario) {
          case 'success':
            return createMockTile().then(buffer => ({
              ok: true,
              status: 200,
              arrayBuffer: () => Promise.resolve(buffer)
            }));

          case 'tile-fail':
            return Promise.resolve({
              ok: false,
              status: 404,
              arrayBuffer: () => Promise.reject(new Error('Tile fetch failed: 404'))
            });

          case 'timeout':
            return new Promise((resolve, reject) => {
              setTimeout(() => reject(new Error('Network timeout')), 100);
            });

          case 'corrupted':
            return createCorruptedData().then(buffer => ({
              ok: true,
              status: 200,
              arrayBuffer: () => Promise.resolve(buffer)
            }));

          default:
            return createMockTile().then(buffer => ({
              ok: true,
              status: 200,
              arrayBuffer: () => Promise.resolve(buffer)
            }));
        }
      }
      
      // Pass through to original fetch for real URLs
      return originalFetch(url, ...args);
    };

    // Expose for testing
    window.L = L;
    window.testLayer = testLayer;
    window.leafletLayerLoaded = true;
  </script>
</body>
</html>
