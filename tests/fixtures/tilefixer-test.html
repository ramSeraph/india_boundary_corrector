<!DOCTYPE html>
<html>
<head>
  <title>TileFixer Test</title>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "@india-boundary-corrector/data": "/packages/data/index.js",
        "@india-boundary-corrector/tilefixer": "/packages/tilefixer/dist/index.js",
        "@india-boundary-corrector/layer-configs": "/packages/layer-configs/dist/index.js"
      }
    }
  </script>
  <script type="module">
    import { getPmtilesUrl } from '@india-boundary-corrector/data';
    import { BoundaryCorrector } from '@india-boundary-corrector/tilefixer';
    import { layerConfigs } from '@india-boundary-corrector/layer-configs';

    // Create corrector instance
    const pmtilesUrl = getPmtilesUrl();
    const corrector = new BoundaryCorrector(pmtilesUrl);
    
    // Get a default layer config for testing
    const layerConfig = layerConfigs.get('osm-carto');

    // Helper functions for tests
    const testHelpers = {
      /**
       * Create a blank tile of specified color
       */
      async createBlankTile(size, color) {
        const canvas = new OffscreenCanvas(size, size);
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, size, size);
        const blob = await canvas.convertToBlob({ type: 'image/png' });
        return blob.arrayBuffer();
      },

      /**
       * Create a tile with a single line drawn on it
       */
      async createTileWithLine(size, bgColor, lineColor, points) {
        const canvas = new OffscreenCanvas(size, size);
        const ctx = canvas.getContext('2d');
        
        // Background
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, size, size);
        
        // Draw line
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
        
        const blob = await canvas.convertToBlob({ type: 'image/png' });
        return blob.arrayBuffer();
      },

      /**
       * Create a tile with multiple lines
       */
      async createTileWithMultipleLines(size, bgColor, lineColor, lineArrays) {
        const canvas = new OffscreenCanvas(size, size);
        const ctx = canvas.getContext('2d');
        
        // Background
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, size, size);
        
        // Draw each line
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        for (const points of lineArrays) {
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
          }
          ctx.stroke();
        }
        
        const blob = await canvas.convertToBlob({ type: 'image/png' });
        return blob.arrayBuffer();
      },

      /**
       * Create simple line corrections in vector tile format
       */
      createSimpleLineCorrections(points, layerName) {
        return {
          [layerName]: [
            {
              geometry: [points],
              extent: 4096,
              type: 2, // LineString
              properties: {},
            },
          ],
        };
      },

      /**
       * Analyze pixels in a tile to find colored (non-white) pixels
       */
      async analyzePixels(tileBuffer, size) {
        const blob = new Blob([tileBuffer]);
        const imageBitmap = await createImageBitmap(blob);
        
        const canvas = new OffscreenCanvas(size, size);
        const ctx = canvas.getContext('2d');
        ctx.drawImage(imageBitmap, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;
        
        let coloredPixels = 0;
        let minX = size, maxX = 0, minY = size, maxY = 0;
        
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const idx = (y * size + x) * 4;
            const r = data[idx];
            const g = data[idx + 1];
            const b = data[idx + 2];
            
            // Consider a pixel colored if it's not white (or very close to white)
            if (r < 250 || g < 250 || b < 250) {
              coloredPixels++;
              minX = Math.min(minX, x);
              maxX = Math.max(maxX, x);
              minY = Math.min(minY, y);
              maxY = Math.max(maxY, y);
            }
          }
        }
        
        return {
          coloredPixels,
          minX: coloredPixels > 0 ? minX : 0,
          maxX: coloredPixels > 0 ? maxX : 0,
          minY: coloredPixels > 0 ? minY : 0,
          maxY: coloredPixels > 0 ? maxY : 0,
        };
      },

      /**
       * Get color of a specific pixel
       */
      async getPixelColor(tileBuffer, size, x, y) {
        const blob = new Blob([tileBuffer]);
        const imageBitmap = await createImageBitmap(blob);
        
        const canvas = new OffscreenCanvas(size, size);
        const ctx = canvas.getContext('2d');
        ctx.drawImage(imageBitmap, 0, 0);
        
        const imageData = ctx.getImageData(x, y, 1, 1);
        const data = imageData.data;
        
        return {
          r: data[0],
          g: data[1],
          b: data[2],
          a: data[3],
          isColored: data[0] < 250 || data[1] < 250 || data[2] < 250,
        };
      },

      /**
       * Compare pixel counts between two tiles
       */
      comparePixelCounts(before, after) {
        return {
          reduction: before.coloredPixels - after.coloredPixels,
          reductionPercent: ((before.coloredPixels - after.coloredPixels) / before.coloredPixels) * 100,
        };
      },
    };

    // Expose for testing
    window.corrector = corrector;
    window.layerConfig = layerConfig;
    window.testHelpers = testHelpers;
    window.tilefixerLoaded = true;
  </script>
</body>
</html>
