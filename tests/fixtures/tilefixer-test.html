<!DOCTYPE html>
<html>
<head>
  <title>TileFixer Test</title>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "@india-boundary-corrector/data": "/packages/data/index.js",
        "@india-boundary-corrector/tilefixer": "/packages/tilefixer/dist/index.js",
        "@india-boundary-corrector/layer-configs": "/packages/layer-configs/dist/index.js"
      }
    }
  </script>
  <script type="module">
    import { getPmtilesUrl } from '@india-boundary-corrector/data';
    import { BoundaryCorrector, getLineWidth } from '@india-boundary-corrector/tilefixer';
    import { layerConfigs } from '@india-boundary-corrector/layer-configs';

    // Create corrector instance
    const pmtilesUrl = getPmtilesUrl();
    const corrector = new BoundaryCorrector(pmtilesUrl);
    
    // Get a default layer config for testing
    const layerConfig = layerConfigs.get('osm-carto');

    // Expose getLineWidth for direct testing
    window.getLineWidth = getLineWidth;

    // Helper functions for tests
    const testHelpers = {
      /**
       * Create a blank tile of specified color
       */
      async createBlankTile(size, color) {
        const canvas = new OffscreenCanvas(size, size);
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, size, size);
        const blob = await canvas.convertToBlob({ type: 'image/png' });
        return blob.arrayBuffer();
      },

      /**
       * Create a tile with a single line drawn on it
       */
      async createTileWithLine(size, bgColor, lineColor, points) {
        const canvas = new OffscreenCanvas(size, size);
        const ctx = canvas.getContext('2d');
        
        // Background
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, size, size);
        
        // Draw line
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
        
        const blob = await canvas.convertToBlob({ type: 'image/png' });
        return blob.arrayBuffer();
      },

      /**
       * Create a tile with multiple lines
       */
      async createTileWithMultipleLines(size, bgColor, lineColor, lineArrays) {
        const canvas = new OffscreenCanvas(size, size);
        const ctx = canvas.getContext('2d');
        
        // Background
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, size, size);
        
        // Draw each line
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        for (const points of lineArrays) {
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
          }
          ctx.stroke();
        }
        
        const blob = await canvas.convertToBlob({ type: 'image/png' });
        return blob.arrayBuffer();
      },

      /**
       * Create simple line corrections in vector tile format
       */
      createSimpleLineCorrections(points, layerName) {
        return {
          [layerName]: [
            {
              geometry: [points],
              extent: 4096,
              type: 2, // LineString
              properties: {},
            },
          ],
        };
      },

      /**
       * Analyze pixels in a tile to find colored (non-white) pixels
       */
      async analyzePixels(tileBuffer, size) {
        const blob = new Blob([tileBuffer]);
        const imageBitmap = await createImageBitmap(blob);
        
        const canvas = new OffscreenCanvas(size, size);
        const ctx = canvas.getContext('2d');
        ctx.drawImage(imageBitmap, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;
        
        let coloredPixels = 0;
        let minX = size, maxX = 0, minY = size, maxY = 0;
        
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const idx = (y * size + x) * 4;
            const r = data[idx];
            const g = data[idx + 1];
            const b = data[idx + 2];
            
            // Consider a pixel colored if it's not white (or very close to white)
            if (r < 250 || g < 250 || b < 250) {
              coloredPixels++;
              minX = Math.min(minX, x);
              maxX = Math.max(maxX, x);
              minY = Math.min(minY, y);
              maxY = Math.max(maxY, y);
            }
          }
        }
        
        return {
          coloredPixels,
          minX: coloredPixels > 0 ? minX : 0,
          maxX: coloredPixels > 0 ? maxX : 0,
          minY: coloredPixels > 0 ? minY : 0,
          maxY: coloredPixels > 0 ? maxY : 0,
        };
      },

      /**
       * Get color of a specific pixel
       */
      async getPixelColor(tileBuffer, size, x, y) {
        const blob = new Blob([tileBuffer]);
        const imageBitmap = await createImageBitmap(blob);
        
        const canvas = new OffscreenCanvas(size, size);
        const ctx = canvas.getContext('2d');
        ctx.drawImage(imageBitmap, 0, 0);
        
        const imageData = ctx.getImageData(x, y, 1, 1);
        const data = imageData.data;
        
        return {
          r: data[0],
          g: data[1],
          b: data[2],
          a: data[3],
          isColored: data[0] < 250 || data[1] < 250 || data[2] < 250,
        };
      },

      /**
       * Compare pixel counts between two tiles
       */
      comparePixelCounts(before, after) {
        return {
          reduction: before.coloredPixels - after.coloredPixels,
          reductionPercent: ((before.coloredPixels - after.coloredPixels) / before.coloredPixels) * 100,
        };
      },

      /**
       * Convert ArrayBuffer to base64 string for saving
       */
      arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.byteLength; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      },
    };

    // Mock fetch for fetchAndFixTile tests
    const originalFetch = window.fetch;
    
    window.createMockTileUrl = (scenario) => {
      return `mock://${scenario}/tile.png`;
    };

    window.fetch = function(url, options = {}) {
      if (typeof url === 'string' && url.startsWith('mock://')) {
        const parts = url.split('/');
        const scenario = parts[2];

        switch (scenario) {
          case 'success':
            return testHelpers.createBlankTile(256, 'white').then(buffer => ({
              ok: true,
              status: 200,
              arrayBuffer: () => Promise.resolve(buffer)
            }));

          case 'tile-fail':
            return Promise.resolve({
              ok: false,
              status: 404,
              arrayBuffer: () => Promise.reject(new Error('Tile fetch failed: 404'))
            });

          case 'timeout':
            return new Promise((resolve, reject) => {
              setTimeout(() => reject(new Error('Network timeout')), 100);
            });

          case 'corrupted':
            const arr = new Uint8Array(100);
            for (let i = 0; i < 100; i++) arr[i] = Math.floor(Math.random() * 256);
            return Promise.resolve({
              ok: true,
              status: 200,
              arrayBuffer: () => Promise.resolve(arr.buffer)
            });

          case 'abort':
            return new Promise((resolve, reject) => {
              if (options.signal) {
                options.signal.addEventListener('abort', () => {
                  const err = new Error('Aborted');
                  err.name = 'AbortError';
                  reject(err);
                });
              }
              // Never resolves unless aborted
            });

          default:
            return testHelpers.createBlankTile(256, 'white').then(buffer => ({
              ok: true,
              status: 200,
              arrayBuffer: () => Promise.resolve(buffer)
            }));
        }
      }
      
      return originalFetch(url, options);
    };

    // Expose for testing
    window.corrector = corrector;
    window.layerConfig = layerConfig;
    window.testHelpers = testHelpers;
    window.tilefixerLoaded = true;
  </script>
</body>
</html>
